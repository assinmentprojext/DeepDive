## 1. 변수의 생명 주기

### 1. 지역 변수: 함수 생성 시 생성, 일반적으로 함수 종료 시 소멸

1. 전역 변수 생성문은 프로그램 시작 시 가장 먼저 평가된다.
2. 하지만 지역 변수 생성문은 함수 시작 시 **해당 함수의 명령문** 중 가장 먼저 실행된다.
    - 아래 코드의 함수가 실행되면, 가장 먼저 x의 값이 undefined로 초기화된다. 그 다음 변수 선언문 위의 코드가 실행되고, 변수 선언문을 만나면 변수 x는 undefined에서 "local"로 값이 바뀐다. 함수 종료 시 변수 x는 사라진다.
    ```javascript
    function foo() {
        console.log(1);
        var x = "local";
        console.log(x);
        return x;
    }
    foo();
    console.log(x);
    ```
3. 일반적으로 지역 변수는 함수 종료 시 소멸되지만 그렇지 않은 경우도 있다.
    - 스코프도 메모리 공간과 마찬가지로 참조하고 있는 이가 더 이상 없을 때 가비지 컬렉터에 의해 소멸된다. -> 함수가 종료되더라도 누군가 해당 함수의 지역 스코프를 참조하고 있다면 그 스코프는 소멸되지 않는다. (24장 연결 필요)

### 2. 전역 변수: 프로그램 실행 시 생성, 프로그램 종료 시 소멸

## 2. 전역 변수의 문제점

### 1. 암묵적 결합

-   모든 코드가 전역 변수를 참조하고 변경할 수 있다는 의미

### 2. 긴 생명 주기

-   메모리 낭비

### 3.스코프 체인 상에서 종점에 존재->검색에 시간이 오래 걸림

### 4. 네임스페이스 오염

-   JS의 전역 변수는 파일이 다르더라도 같은 전역 스코프를 공유하므로 네임스페이스 오염에 취약하다.

## 3. 전역 변수 사용을 억제하는 방법

### 1. 즉시 실행 함수

```javascript
(function () {
    var foo = 10;
    // do something
})();

console.log(foo);
```

### 2. 네임스페이스 객체

```javascript
const MyApp = {
    name: "Aatrox",
    address: "???",
};

console.log(MyApp.name);
```

\*네임스페이스 객체도 결국 전역 변수에 할당되므로 네임스페이스 오염 방지 외의 효과를 기대할 수 없다.

### 3. 모듈 패턴

```javascript
let Counter = (function (){
    //private 변수
    let num = 0;

    return {
        increase(){
            return num++;
        }
        decrease(){
            return --num;
        }
    };
}())

console.log(Counter.num);//undefined가 나온다.
```

(24장 연결 필요)

### 4. ES6 모듈

(48장, 49장 연결 필요)
